# [使用依赖指南](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id3)

内容

- [使用依赖指南](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#using-dependencies-guide)
  - [介绍](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#introduction)
  - [使用预构建的包`find_package()`](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#using-pre-built-packages-with-find-package)
    - [配置文件包](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#config-file-packages)
    - [查找模块文件](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#find-module-files)
    - [导入的目标](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#imported-targets)
  - [从源代码下载和构建`FetchContent`](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#downloading-and-building-from-source-with-fetchcontent)
  - [`FetchContent`与`find_package()`整合](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#fetchcontent-and-find-package-integration)
  - [依赖提供者](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#dependency-providers)

## [Introduction](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id4)

项目将经常依赖于其他项目、资产和工件。CMake 提供了许多方法来将这些东西合并到构建中。项目和用户可以灵活地选择最适合他们需要的方法。

将依赖项引入构建的主要方法是 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令和[`FetchContent`](https://cmake.org/cmake/help/latest/module/FetchContent.html#module:FetchContent)模块。这[`FindPkgConfig`](https://cmake.org/cmake/help/latest/module/FindPkgConfig.html#module:FindPkgConfig)有时也会使用模块，尽管它缺少其他两个模块的一些集成，并且在本指南中没有进一步讨论。

依赖项也可以由自定义 [依赖项提供程序提供](https://cmake.org/cmake/help/latest/command/cmake_language.html#dependency-providers)。这可能是第三方包管理器，也可能是开发人员实现的自定义代码。依赖提供者与上面提到的主要方法合作以扩展它们的灵活性。



## [使用预构建的包`find_package()`](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id5)

项目所需的包可能已经在用户系统的某个位置构建并可用。该软件包也可能是由 CMake 构建的，或者它可能完全使用了不同的构建系统。它甚至可能只是一个根本不需要构建的文件集合。CMake 提供[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)这些场景的命令。它搜索众所周知的位置，以及项目或用户提供的其他提示和路径。它还支持包组件和包是可选的。提供结果变量以允许项目根据是否找到包或特定组件来自定义其自己的行为。

在大多数情况下，项目通常应该使用[Basic Signature](https://cmake.org/cmake/help/latest/command/find_package.html#basic-signature)。大多数情况下，这将只涉及包名称，可能是版本约束，以及`REQUIRED`如果依赖项不是可选的关键字。也可以指定一组包组件。

`find_package()`基本签名示例

```
find_package(Catch2)
find_package(GTest REQUIRED)
find_package(Boost 1.79 COMPONENTS date_time)
```

这[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令支持执行搜索的两种主要方法：

- **配置模式**

  使用此方法，该命令会查找通常由包本身提供的文件。这是两者中更可靠的方法，因为包详细信息应始终与包同步。

- **模块模式**

  并非所有软件包都支持 CMake。许多不提供支持配置模式所需的文件。对于这种情况，可以由项目或 CMake 单独提供 Find 模块文件。Find 模块通常是一种启发式实现，它知道包通常提供什么以及如何将该包呈现给项目。由于 Find 模块通常与包分开分发，因此它们不那么可靠。它们通常是单独维护的，并且可能遵循不同的发布时间表，因此它们很容易过时。

根据所使用的论据，[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)可以使用上述方法中的一种或两种。通过将选项限制为仅基本签名，可以使用配置模式和模块模式来满足依赖关系。其他选项的存在可能会将调用限制为仅使用两种方法中的一种，从而可能降低命令查找依赖项的能力。见[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)有关此复杂主题的完整详细信息的文档。

对于这两种搜索方法，用户还可以在 [`cmake(1)`](https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1))命令行或在[`ccmake(1)`](https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1))或者 [`cmake-gui(1)`](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1))用于影响和覆盖在何处查找包的 UI 工具。 有关如何设置缓存变量的更多信息，请参阅[用户交互指南。](https://cmake.org/cmake/help/latest/guide/user-interaction/index.html#setting-build-variables)



### [配置文件包](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id6)

第三方提供与 CMake 一起使用的可执行文件、库、头文件和其他文件的首选方式是提供 [配置文件](https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#config-file-packages)。这些是软件包附带的文本文件，用于定义 CMake 目标、变量、命令等。配置文件是一个普通的 CMake 脚本，由 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令。

配置文件通常可以在名称与模式匹配的目录中找到`lib/cmake/<PackageName>`，尽管它们可能位于其他位置（请参阅[配置模式搜索过程](https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure)）。通常`<PackageName>`是第一个参数[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令，它甚至可能是唯一的参数。也可以使用以下`NAMES` 选项指定替代名称：

查找包时提供替代名称

```
find_package(SomeThing
  NAMES
    SameThingOtherName   # Another name for the package
    SomeThing            # Also still look for its canonical name
)
```

配置文件必须命名为`<PackageName>Config.cmake`or `<LowercasePackageName>-config.cmake`（前者用于本指南的其余部分，但两者都受支持）。此文件是 CMake 包的入口点。一个单独的可选文件名为 `<PackageName>ConfigVersion.cmake`or `<LowercasePackageName>-config-version.cmake`也可能存在于同一目录中。CMake 使用此文件来确定包的版本是否满足调用中包含的任何版本约束 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package). 调用时可以选择指定版本 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)，即使存在`<PackageName>ConfigVersion.cmake` 文件。

如果`<PackageName>Config.cmake`找到该文件并且满足任何版本约束，则[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令认为要找到包，并且假定整个包按照设计是完整的。

可能有其他文件提供 CMake 命令或 [导入的目标](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets)供您使用。CMake 不对这些文件强制执行任何命名约定。它们 `<PackageName>Config.cmake`通过使用 CMake 与主文件相关联[`include()`](https://cmake.org/cmake/help/latest/command/include.html#command:include) 命令。该`<PackageName>Config.cmake`文件通常会为您包含这些内容，因此它们通常不需要任何其他步骤，除了调用[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package).

如果包的位置在 [CMake 已知的目录中](https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure)，则 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)调用应该成功。CMake 已知的目录是特定于平台的。例如，使用标准系统包管理器安装在 Linux 上的包将`/usr`自动在前缀中找到。安装在 Windows 上的软件包同样会被自动找到。`Program Files`

如果软件包位于 CMake 不知道的位置，例如`/opt/mylib`或，则不会在没有帮助的情况下自动找到它们`$HOME/dev/prefix`。这是正常情况，CMake 为用户提供了几种方法来指定在哪里可以找到此类库。

这[`CMAKE_PREFIX_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH)[调用 CMake 时](https://cmake.org/cmake/help/latest/guide/user-interaction/index.html#setting-build-variables)可以设置变量 。它被视为搜索 [配置文件](https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#config-file-packages)的基本路径列表。安装的包 `/opt/somepackage`通常会安装配置文件，例如 `/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake`. 在这种情况下，`/opt/somepackage`应添加到 [`CMAKE_PREFIX_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH).

环境变量`CMAKE_PREFIX_PATH`也可以填充前缀以搜索包。与`PATH`环境变量一样，这是一个列表，但它需要使用特定于平台的环境变量列表项分隔符（`:`在 Unix 和`;`Windows 上）。

这[`CMAKE_PREFIX_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH)在需要指定多个前缀或多个包在同一前缀下可用的情况下，变量提供了便利。包的路径也可以通过设置变量匹配来指定`<PackageName>_DIR`，例如 `SomePackage_DIR`. 请注意，这不是前缀，而应该是包含配置样式包文件的目录的完整路径，例如 `/opt/somepackage/lib/cmake/SomePackage`上面的示例。见[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)其他可能影响搜索的 CMake 变量和环境变量的文档。



### [查找模块文件](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id7)

仍然可以找到不提供配置文件的包 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)命令，如果`FindSomePackage.cmake`文件可用。这些 Find 模块文件与配置文件的不同之处在于：

1. 包本身不应该提供查找模块文件。
2. 文件的可用性`Find<PackageName>.cmake`并不表示包或包的任何特定部分的可用性。
3. CMake 不搜索在 [`CMAKE_PREFIX_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html#variable:CMAKE_PREFIX_PATH)文件的变量`Find<PackageName>.cmake` 。相反，CMake 在由[`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH)多变的。用户通常会设置[`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH)运行 CMake 时，CMake 项目通常会附加到[`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH)允许使用本地 Find 模块文件。
4. CMake`Find<PackageName>.cmake`为某些人提供文件 [`third party packages`](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual:cmake-modules(7)). 这些文件是 CMake 的维护负担，并且这些文件落后于与其关联的软件包的最新版本并不罕见。通常，新的 Find 模块不再添加到 CMake。项目应鼓励上游包尽可能提供配置文件。如果不成功，项目应该为包提供自己的 Find 模块。

有关如何编写 Find 模块文件的详细讨论，请参阅[Find Modules 。](https://cmake.org/cmake/help/latest/manual/cmake-developer.7.html#find-modules)



### [导入的目标](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id8)

配置文件和查找模块文件都可以定义[Imported Targets](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#imported-targets)。这些通常具有形式的名称`SomePrefix::ThingName`。如果这些可用，项目应该更喜欢使用它们，而不是可能提供的任何 CMake 变量。此类目标通常带有使用要求，并自动将诸如标头搜索路径、编译器定义等内容应用于链接到它们的其他目标（例如，使用 [`target_link_libraries()`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command:target_link_libraries)）。这比尝试使用变量手动应用相同的东西更健壮也更方便。检查包或查找模块的文档以查看它定义的导入目标（如果有）。

导入的目标还应封装任何特定于配置的路径。这包括二进制文件（库、可执行文件）的位置、编译器标志和任何其他与配置相关的数量。查找模块在提供这些详细信息方面可能不如配置文件可靠。

查找第三方包并使用其中的库的完整示例可能如下所示：

```
cmake_minimum_required(VERSION 3.10)
project(MyExeProject VERSION 1.0.0)

# Make project-provided Find modules available
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

find_package(SomePackage REQUIRED)
add_executable(MyExe main.cpp)
target_link_libraries(MyExe PRIVATE SomePrefix::LibName)
```

请注意，上面的调用[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)可以通过配置文件或查找模块来解决。它仅使用[Basic Signature](https://cmake.org/cmake/help/latest/command/find_package.html#basic-signature)支持的基本参数。`FindSomePackage.cmake`目录中的 文件`${CMAKE_CURRENT_SOURCE_DIR}/cmake`将允许 [`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)例如，使用模块模式成功的命令。如果不存在这样的模块文件，系统将搜索配置文件。

## [`FetchContent`](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id9)[从源代码下载和构建](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id9)

依赖项不一定必须预先构建才能与 CMake 一起使用。它们可以作为主项目的一部分从源代码构建。这[`FetchContent`](https://cmake.org/cmake/help/latest/module/FetchContent.html#module:FetchContent)如果依赖项也使用 CMake，模块提供下载内容（通常是源，但可以是任何内容）并将其添加到主项目的功能。依赖项的源将与项目的其余部分一起构建，就像源是项目自身源的一部分一样。

一般模式是项目应该首先声明它想要使用的所有依赖项，然后要求它们可用。下面演示了这个原理（更多请参见[示例](https://cmake.org/cmake/help/latest/module/FetchContent.html#fetch-content-examples) ）：

```
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0
)
FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        de6fe184a9ac1a06895cdd1c9b437f0a0bdf14ad # v2.13.4
)
FetchContent_MakeAvailable(googletest Catch2)
```

支持各种下载方法，包括从 URL 下载和提取档案（支持一系列档案格式），以及包括 Git、Subversion 和 Mercurial 在内的多种存储库格式。自定义下载、更新和补丁命令也可用于支持任意用例。

当将依赖项添加到项目中时[`FetchContent`](https://cmake.org/cmake/help/latest/module/FetchContent.html#module:FetchContent)，项目链接到依赖项的目标，就像项目中的任何其他目标一样。如果依赖项提供了 form 的命名空间目标 `SomePrefix::ThingName`，则项目应该链接到这些目标而不是任何非命名空间目标。请参阅下一节了解为什么建议这样做。

并非所有依赖项都可以通过这种方式引入项目。一些依赖项定义了名称与项目中的其他目标或其他依赖项发生冲突的目标。具体的可执行文件和库目标由[`add_executable()`](https://cmake.org/cmake/help/latest/command/add_executable.html#command:add_executable)和[`add_library()`](https://cmake.org/cmake/help/latest/command/add_library.html#command:add_library)是全局的，因此每个在整个构建中都必须是唯一的。如果依赖项会添加冲突的目标名称，则无法使用此方法将其直接带入构建中。

## [`FetchContent`和`find_package()`集成](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id10)

*版本 3.24 中的新功能。*

一些依赖项支持被添加[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)或者 [`FetchContent`](https://cmake.org/cmake/help/latest/module/FetchContent.html#module:FetchContent). 此类依赖项必须确保它们在已安装和从源代码构建的场景中定义相同的命名空间目标。然后，消费项目链接到那些命名空间的目标，并且可以透明地处理这两种情况，只要项目不使用两种方法都没有提供的任何其他东西。

`FIND_PACKAGE_ARGS`该项目可以使用以下选项表明它很乐意通过任一方法接受依赖项[`FetchContent_Declare()`](https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_declare). 这允许[`FetchContent_MakeAvailable()`](https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_makeavailable)尝试通过调用来满足依赖关系[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)首先，使用关键字后面的`FIND_PACKAGE_ARGS`参数（如果有）。如果没有找到依赖项，则它是从源代码构建的，如前所述。

```
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0
  FIND_PACKAGE_ARGS NAMES GTest
)
FetchContent_MakeAvailable(googletest)

add_executable(ThingUnitTest thing_ut.cpp)
target_link_libraries(ThingUnitTest GTest::gtest_main)
```

上面的例子调用 [`find_package(googletest NAMES GTest)`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)第一的。CMake 提供了一个[`FindGTest`](https://cmake.org/cmake/help/latest/module/FindGTest.html#module:FindGTest)模块，因此如果发现某个地方安装了 GTest 包，它将使其可用，并且不会从源代码构建依赖项。如果没有找到 GTest 包，它将*从*源代码构建。无论哪种情况，`GTest::gtest_main`都需要定义目标，因此我们将单元测试可执行文件链接到该目标。

高级控制也可通过 [`FETCHCONTENT_TRY_FIND_PACKAGE_MODE`](https://cmake.org/cmake/help/latest/module/FetchContent.html#variable:FETCHCONTENT_TRY_FIND_PACKAGE_MODE)多变的。这可以设置 `NEVER`为禁用所有重定向到[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package). 可以设置`ALWAYS`试试[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)即使`FIND_PACKAGE_ARGS` 未指定（应谨慎使用）。

该项目还可能决定必须从源代码构建特定的依赖项。如果需要补丁或未发布版本的依赖项，或者满足某些需要从源构建所有依赖项的策略，则可能需要这样做。该项目可以通过将`OVERRIDE_FIND_PACKAGE`关键字添加到[`FetchContent_Declare()`](https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_declare). 打电话给[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)因为该依赖项将被重定向到[`FetchContent_MakeAvailable()`](https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_makeavailable)反而。

```
include(FetchContent)
FetchContent_Declare(
  Catch2
  URL https://intranet.mycomp.com/vendored/Catch2_2.13.4_patched.tgz
  URL_HASH MD5=abc123...
  OVERRIDE_FIND_PACKAGE
)

# The following is automatically redirected to FetchContent_MakeAvailable(Catch2)
find_package(Catch2)
```

有关更高级的用例，请参阅 [`CMAKE_FIND_PACKAGE_REDIRECTS_DIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_PACKAGE_REDIRECTS_DIR.html#variable:CMAKE_FIND_PACKAGE_REDIRECTS_DIR)多变的。



## [依赖提供者](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html#id11)

*版本 3.24 中的新功能。*

上一节讨论了项目可以用来指定其依赖项的技术。理想情况下，项目不应该真正关心依赖项来自哪里，只要它提供了它期望的东西（通常只是一些导入的目标）。在没有任何其他细节的情况下，该项目说明了它需要什么，并且还可以指定从哪里获取它，以便它仍然可以开箱即用地构建。

另一方面，开发人员可能对控制 *如何*向项目提供依赖项更感兴趣。您可能希望使用自己构建的特定版本的包。您可能想要使用第三方包管理器。出于安全或性能原因，您可能希望将某些请求重定向到您控制的系统上的不同 URL。[CMake 通过Dependency Providers](https://cmake.org/cmake/help/latest/command/cmake_language.html#dependency-providers)支持这些场景 。

依赖提供者可以设置为拦截[`find_package()`](https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package)和 [`FetchContent_MakeAvailable()`](https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_makeavailable)来电。如果提供者不满足，提供者有机会在回退到内置实现之前满足此类请求。

只能设置一个依赖提供程序，并且只能在 CMake 运行早期的一个非常特定的时间点设置。这[`CMAKE_PROJECT_TOP_LEVEL_INCLUDES`](https://cmake.org/cmake/help/latest/variable/CMAKE_PROJECT_TOP_LEVEL_INCLUDES.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES)变量列出了在处理第一个文件时将读取的 CMake 文件[`project()`](https://cmake.org/cmake/help/latest/command/project.html#command:project)呼叫（并且只有那个呼叫）。这是唯一一次可以设置依赖提供者。在整个项目中最多只能使用一个提供商。

对于某些场景，用户不需要知道如何设置依赖提供者的细节。第三方可以提供可以添加到[`CMAKE_PROJECT_TOP_LEVEL_INCLUDES`](https://cmake.org/cmake/help/latest/variable/CMAKE_PROJECT_TOP_LEVEL_INCLUDES.html#variable:CMAKE_PROJECT_TOP_LEVEL_INCLUDES)，它将代表用户设置依赖提供者。这是包管理器的推荐方法。开发人员可以像这样使用这样的文件：

```
cmake -DCMAKE_PROJECT_TOP_LEVEL_INCLUDES=/path/to/package_manager/setup.cmake ...
```

有关如何实现自己的自定义依赖提供程序的详细信息，请参阅 [`cmake_language(SET_DEPENDENCY_PROVIDER)`](https://cmake.org/cmake/help/latest/command/cmake_language.html#command:cmake_language)命令。